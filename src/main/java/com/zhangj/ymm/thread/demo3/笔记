1:结束一个JVM生命周期的方式
    1:System.exit();
    2:Normal finish done;
    3:Encounter the error or exception
    4:Crash
    5:OS problems and others
2:类加载的三个阶段
    加载:查找并且加载类的二进制数据
    链接:
        验证:确保被加载类的正确性
        准备:为类的静态变量分配内存,并将其初始化为默认值
        解析:把类中的符号引用转换为直接引用
    初始化:为类的静态变量赋予正确的初始值
3:类主动使用的分类
    1:new ,直接使用.
    2:访问某个类或者接口的静态变量,或者对静态变量经行赋值操作.
        1.对某个类的静态变量进行读写=>加载class.
        2.对某个接口的静态变量进行读取=>加载class.
    3:调用类的静态方法.
    4:反射某个类.
    5:初始化一个子类,其父类也会被初始化.
    6:启动类,main函数.
    7:子类访问父类的静态变量,子类不会初始化.
    8:通过数组 Obj[] arrays = new Obj[10]; 不会初始化类.
    9:访问final修饰的常量会在编译期间放在常量池中,不会初始化类.
    10:访问final修饰的复杂类型,在编译期间无法计算得出,会初始化类.
4:类加载阶段详解
    1:类的加载简单的说,就是将class文件中的二进制数据读取到内存中,将其放在方法区中,然后在堆中创建一个java.lang.Class对象,用来
    封装在方法区中的数据结构.
    2:加载类的方式
        本地磁盘中加载
        内存中直接加载
        通过网络加载.class
        从zip,jar等归档文件中加载.class
        从数据库中提取.class
        动态编译
5:链接阶段
    1:在加载阶段完成后,虚拟机外部的二进制数据就会按照虚拟机所需要的格式存储在方法区中(数据结构),然后在堆中创建一个Class
    对象,这个对象作为程序访问方法区中这些数据结构的外部接口.
    2:加载阶段和链接阶段的部分内容可以交叉进行的,比如一部分代码记载完成就可以经行验证,提高效率.
6:验证
    1:验证的主要目的是确保Class文件中的字节流包含的信息是否符合虚拟机的要求,并且不会损害到JVM自身的安全.
    2:verifyError
    3:文件格式验证
        1:魔法因子是否正确
        2:版本号是否符合当前虚拟机
        3:常量池中的常量类型是不是不支持
        4:etc
    4:元数据验证
        1:是否有父类
        2:父类是否允许继承
        3:是否实现了抽象方法
        4:是否覆盖了父类的final字段
        5:其他语义检查
    5:字节码验证
        1:  主要进行数据流和控制流的分析,不会出现这样的情况,在操作栈中放置了一个int类型,但却给了一个long类型的数据.
    6:符号引用验证
        调用了一个不存在方法,字段等等
7:准备:给类变量赋初始值
8:解析:把符号引用变为直接引用
    1:类或者接口的解析
    2:字段解析
    3:类方法解析
    4:接口方法解析
9:类的卸载以及classloader的卸载
    JVM中的Class只有满足一下三个条件,才能被GC回收:
    1:该类所有的实例都已经被GC
    2:加载该类的ClassLoader实例已经被回收
    3:该类的java.lang.Class对象没有任何地方被引用
